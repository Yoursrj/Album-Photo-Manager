//You and I are going to import a function from Redux Toolkit query called Fetch Base Query.
//This is a function that you and I are going to call and it's going to give us a preconfigured version of fetch, a version of fetch that already has a couple of options assigned to it.
//We're then going to take that version of fetch and we're going to pass it off to Redux Toolkit query.Now, one thing I really want to clarify here.
//This function called fetch base query.This is imported from Redux Toolkit query.And I think that in my opinion here, it's totally my opinion.
//This is not a very well named function because when I see fetch base query, I kind of read that as,Hey, if you call this thing, it's going to go and make a request right away.
//That's not what is happening here.Fetch base query again is going to give you a preconfigured version of fetch.So it's kind of like a configuration function.
import {createApi, fetchBaseQuery} from '@reduxjs/toolkit/query/react';
import {faker}  from '@faker-js/faker';
//In this section, we import the necessary functions and dependencies. We import createApi and fetchBaseQuery from Redux Toolkit Query, which are used to create and configure the API. 
//We also import faker from the @faker-js/faker library, which will be used to generate fake data for our example.

//DEV ONLY!!!  
const pause = (duration) =>{
  return new Promise((resolve) =>{
   setTimeout(resolve,duration)
  });
};
//Here, we define a helper function called pause, which returns a promise that resolves after a specified duration.
// This function is used to simulate a delay in the network request for demonstration purposes.


//OBJECTIVE OF THIS FILE---
//And we're going to write out some code that looks like this right here.Now, when we use the term API, that's a really loaded term.
//In other words, it has a lot of meanings to different people.When we are using Redux Toolkit query and we refer to an API, we're kind of talking about some client side code that we're going to write in our React application.
//And its goal is to provide an interface to go and fetch data.So when I say we're going to create an API, I do not mean to say we were going to create a back end server.
//That's not what is happening here.We are adding in some code that is going to go and fetch some data.We're going to add this code to the React side of our project.
//When we create this API thing, we're going to call this create API function that is coming from Redux Toolkit.
//And when we create this API, we're going to add in a ton of configuration.There's a lot of config we have to add in here.And of course, that's what we're going to spend a lot of time learning.
const albumsApi = createApi({
//We create an API using the createApi function from Redux Toolkit Query. 

//reducerPath---
//Here is our big state object.Our state object already has a user's slice assigned to it.So there's all the user's related stuff that we've already added in.
//Now we're about to add in a brand new slice that is going to be generated by this albums API.Again, that slice is going to have a ton of state tied to it.
//Here are some of the sample properties you would find inside there.So the goal of this reducer path is super simple.
//The reducer path is used to just specify where's all the state going to be stored inside of the big state object? What is the key?
//That's all it does.So the reducer path is going to be a string.It's going to specify the key.We want to store all the states related to this API.
//We are usually going to use a reducer path that is kind of named after the API itself, but it can be anything we want.The only requirement is that it is not the same key as another key
//So in this case, we would not be allowed to give it a key of users because that's already in use.
reducerPath : 'albums',//index.js line 27

//This function takes a configuration object as an argument. Inside the configuration object, we specify the reducerPath as 'albums', which is the key under which the state related to this API will be stored in the Redux store(upar wala index.js).
//The base URL.Is like the base or kind of the root URL of the server that we want to make request to.
//So for you and I, the base URL is the kind of base your URL.I can't think of a better word for it than that.
//It's just the base URL of JSON server.That's pretty much it.Where is our server hosted?
//Our server is hosted at and is running at http colon slash local host.3005.
baseQuery : fetchBaseQuery({
    baseUrl:'http://localhost:3005',
    //We also configure the baseQuery using fetchBaseQuery. Here, we provide the baseUrl as 'http://localhost:3005', which is the root URL of the server we want to make requests to.
    fetchFn : async(...args) =>{
    // We also define the fetchFn function, which is used to perform the actual network request. 
    //In this case, we add a delay of 1 second using the pause helper function before making the actual fetch call.
      //remove for production
      await pause (1000);
      return fetch(...args);
    }
}),
//It's going to contain some different kind of redux primitives inside of it.We're going to get back a slice.
//So remember, a slice is going to contain a combined reducer.Some of those many reducers, a bunch of action creator functions and so on.
//This API thing is also going to contain some different thunk functions as well.If you skip the last section on chunks, that's totally fine.
//It turns out that we don't really have to interact with these things at all.We barely even see them when we create this API thing.
//What we really care about as a side effect or what comes out of creating this API is a collection of different hooks.This is what we care about.
//These hooks are going to automate the data fetching process inside of our components.They're going to make fetching data and showing loading spinners, handling errors, all that kind ofstuff.


//Inside the endpoints function, we define three endpoints: removeAlbum, addAlbum, and fetchAlbums. These endpoints represent different actions we can perform with the API.
endpoints(builder){
    return{
      //removeAlbum is a mutation endpoint that specifies how to make a request to delete an album. It includes a query function that returns an object with the URL and method for the request.
      // It also includes an invalidatesTags function that specifies which tags should be invalidated when this mutation is executed.
      removeAlbum:builder.mutation({
        invalidatesTags:(result,error,album) => {
          return [{type:'Album',id:album.id}]
        },
        //query(album):
        //This query function is defined within the removeAlbum endpoint.
            query : (album) => {
              return{
                url: `/albums/${album.id}`,
                method:'DELETE'
              };
            }
      }),
      addAlbum : builder.mutation({//addAlbum is another mutation endpoint that specifies how to make a request to create an album. 
        invalidatesTags : (result , error , user) => {// It also includes an invalidatesTags function that specifies which tags should be invalidated when this mutation is executed.
          return [{ type: 'UsersAlbums' , id:user.id }]
        },
//Notice the mutation right there.So immediately visible to other engineers that this is going to tell Redux Toolkit query how to make a request that is going to change some data.
//Inside this object.We're still going to add in a query function.And I know right away it's a little bit confusing that we're adding in something called query to a mutation.
//So you should really think of this query function that we are defining down here and right here, not really as a function called query more.It's a function that's being used to tell redux to a get query about some parameters to use for the request.
//When we make this request, we need to know what user we want to tie this album to.So we're going to assume that we're going to receive a user as an argument to this function.
//I'm then going to return an object.And inside of here, once again, we're going to put in all the answers to those questions we just went over.        
      query : (user) =>{//It includes a query function that returns an object with the URL, method, and body for the request.
//Now, when we use a mutation, things are a little bit different.Remember, a mutation is going to change data on our server.So think about when you want to change data.
//Well, usually we want to change data stored on our server in response to some user input, such as user clicking on a save button or typing or submitting a form or something like that.
//So when we make use of a mutation hook, we get back in array with a couple of elements inside of it.The first element is a function, and when you call that, that is when your mutation actually gets executed.
//The second element, which I called results in this case is an object very similar to the one that gets returned from a query hook.
//So it is an object that has some properties such as is loading is air.Was there an error? Errors. Objects.Objects.When the last mutation was executed, data returned from the server, from that mutation, and so on.
      return{
        url:'/albums',
        method : 'POST',
        body:{
            userId : user.id,
            title : faker.commerce.productName()
        }
      };
      }
      }),
      fetchAlbums : builder.query({//fetchAlbums is a query endpoint that specifies how to make a request to fetch albums. 
        //It includes a query function that returns an object with the URL, method, and params for the request.
        providesTags : (result , error , user) => {// It also includes a providesTags function that specifies which tags are provided by the result of this query.
          //  return [{ type : 'Album', id:user.id }]
          const tags = result.map(album=>{
            return {type:'Album',id:album.id}
          })
          tags.push({type:'UsersAlbums',id:user.id});
          return tags;
        },
        //query(user):
        //This query function is defined within the addAlbum endpoint.
        //It takes a user object as an argument.
        query: (user) =>{
            return{
              url : '/albums',
              params:{
                userId : user.id
              },
              method:'GET'
            };
        }
      })
    };
}
});

export const {useFetchAlbumsQuery,useAddAlbumMutation,useRemoveAlbumMutation} = albumsApi;
//Finally, we export the generated hooks for each endpoint (useFetchAlbumsQuery, useAddAlbumMutation, useRemoveAlbumMutation) so that they can be used in our React components.
//We also export the albumsApi object, which contains the API configuration.
export {albumsApi};

//That's a high-level explanation of the code. 
//The code sets up an API using Redux Toolkit Query, configures endpoints for different actions, and exports hooks to use in React components for fetching data and performing mutations.